//
// CandyMachineSearchRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct CandyMachineSearchRequest: Codable, JSONEncodable, Hashable {

    public enum UpdateAuthoritySearchMethod: String, Codable, CaseIterable {
        case exactMatch = "exact_match"
    }
    public enum ConfigAddressSearchMethod: String, Codable, CaseIterable {
        case exactMatch = "exact_match"
    }
    public enum UuidSearchMethod: String, Codable, CaseIterable {
        case exactMatch = "exact_match"
    }
    public enum SymbolSearchMethod: String, Codable, CaseIterable {
        case beginsWith = "begins_with"
        case exactMatch = "exact_match"
    }
    public enum NftNameSearchMethod: String, Codable, CaseIterable {
        case beginsWith = "begins_with"
        case exactMatch = "exact_match"
    }
    public enum Network: String, Codable, CaseIterable {
        case devnet = "devnet"
        case mainnetBeta = "mainnet-beta"
    }
    public enum CandyMachineContractVersion: String, Codable, CaseIterable {
        case v1 = "v1"
        case v2 = "v2"
    }
    /** The public key of the update authority of the candy machine */
    public var updateAuthority: String?
    /** Only `exact_match` supported at this time */
    public var updateAuthoritySearchMethod: UpdateAuthoritySearchMethod? = .exactMatch
    /** The public key of the configuration of the candy machine */
    public var configAddress: String?
    /** Only `exact_match` supported at this time */
    public var configAddressSearchMethod: ConfigAddressSearchMethod? = .exactMatch
    /** The alphanumeric string of length six that corresponds to the candy machine. This is NOT the candy machine ID.  This is the first six letters of the configuration address and is also used to identify the candy machine. An example is `4zKV6i`.  */
    public var uuid: String?
    /** Only `exact_match` supported at this time */
    public var uuidSearchMethod: UuidSearchMethod? = .exactMatch
    /** The symbol associated with the candy machine */
    public var symbol: String?
    public var symbolSearchMethod: SymbolSearchMethod? = .exactMatch
    /** The name of an NFT on the candy machine, minted or unminted. For example, to find The Solana Money Boys candy machine, you already know that each NFT is named \"Solana Money Boy #0\", \"Solana Money Boy #1\", and so on. So you could search with  nft_name=\"Solana Money Boy #0\", nft_name_index=0, nft_name_search_method='exact_match', for example, which would return the candy machine ID. This also works with candy machines that are not live but are uploaded.  */
    public var nftName: String?
    /** The index of the NFT to check, e.g., the 2nd NFT would have an index of 1. We cannot search all NFTs on a candy machine currently, so you must search an NFT at a particular position, such as the first, second, and so on. In general, nft_name_index=0 works for most use cases.  */
    public var nftNameIndex: String? = "0"
    public var nftNameSearchMethod: NftNameSearchMethod? = .exactMatch
    public var network: Network? = .devnet
    /** The candy machine contract you want to search.  If you want to search `v1` candy machines, set this to `v1`. If you want to search `v2` candy machines. set this to `v2`.  */
    public var candyMachineContractVersion: CandyMachineContractVersion? = .v1

    public init(updateAuthority: String? = nil, updateAuthoritySearchMethod: UpdateAuthoritySearchMethod? = .exactMatch, configAddress: String? = nil, configAddressSearchMethod: ConfigAddressSearchMethod? = .exactMatch, uuid: String? = nil, uuidSearchMethod: UuidSearchMethod? = .exactMatch, symbol: String? = nil, symbolSearchMethod: SymbolSearchMethod? = .exactMatch, nftName: String? = nil, nftNameIndex: String? = "0", nftNameSearchMethod: NftNameSearchMethod? = .exactMatch, network: Network? = .devnet, candyMachineContractVersion: CandyMachineContractVersion? = .v1) {
        self.updateAuthority = updateAuthority
        self.updateAuthoritySearchMethod = updateAuthoritySearchMethod
        self.configAddress = configAddress
        self.configAddressSearchMethod = configAddressSearchMethod
        self.uuid = uuid
        self.uuidSearchMethod = uuidSearchMethod
        self.symbol = symbol
        self.symbolSearchMethod = symbolSearchMethod
        self.nftName = nftName
        self.nftNameIndex = nftNameIndex
        self.nftNameSearchMethod = nftNameSearchMethod
        self.network = network
        self.candyMachineContractVersion = candyMachineContractVersion
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case updateAuthority = "update_authority"
        case updateAuthoritySearchMethod = "update_authority_search_method"
        case configAddress = "config_address"
        case configAddressSearchMethod = "config_address_search_method"
        case uuid
        case uuidSearchMethod = "uuid_search_method"
        case symbol
        case symbolSearchMethod = "symbol_search_method"
        case nftName = "nft_name"
        case nftNameIndex = "nft_name_index"
        case nftNameSearchMethod = "nft_name_search_method"
        case network
        case candyMachineContractVersion = "candy_machine_contract_version"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(updateAuthority, forKey: .updateAuthority)
        try container.encodeIfPresent(updateAuthoritySearchMethod, forKey: .updateAuthoritySearchMethod)
        try container.encodeIfPresent(configAddress, forKey: .configAddress)
        try container.encodeIfPresent(configAddressSearchMethod, forKey: .configAddressSearchMethod)
        try container.encodeIfPresent(uuid, forKey: .uuid)
        try container.encodeIfPresent(uuidSearchMethod, forKey: .uuidSearchMethod)
        try container.encodeIfPresent(symbol, forKey: .symbol)
        try container.encodeIfPresent(symbolSearchMethod, forKey: .symbolSearchMethod)
        try container.encodeIfPresent(nftName, forKey: .nftName)
        try container.encodeIfPresent(nftNameIndex, forKey: .nftNameIndex)
        try container.encodeIfPresent(nftNameSearchMethod, forKey: .nftNameSearchMethod)
        try container.encodeIfPresent(network, forKey: .network)
        try container.encodeIfPresent(candyMachineContractVersion, forKey: .candyMachineContractVersion)
    }
}

