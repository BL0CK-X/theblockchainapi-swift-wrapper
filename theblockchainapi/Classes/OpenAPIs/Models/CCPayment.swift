//
// CCPayment.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct CCPayment: Codable, JSONEncodable, Hashable {

    /** The ID of the project  */
    public var projectId: String?
    /** The ID of the associated product  */
    public var productId: String?
    /** The ID of the respective plan  */
    public var planId: String?
    /** The unique ID of the payment  */
    public var paymentId: String?
    /** The unique identifier of the wallet from which the payment was made.  */
    public var blockchainIdentifier: String?
    public var blockchainPaymentDetails: CCPaymentBlockchainPaymentDetails?
    /** The ID of the customer  */
    public var customerId: String?
    /** The validation code shown to the customer. This is only visible to the customer who paid. They can use this code to redeem their subscription to their product.  */
    public var paymentValidationCode: String?
    /** A UNIX time stamp, in seconds, that identifies the end of the period of the subscription  */
    public var periodEnd: Double?
    /** A UNIX time stamp, in seconds, that identifies the start of the period of the subscription  */
    public var periodStart: Double?
    /** The string that uniquely identifies the blockchain transaction  */
    public var transactionBlockchainIdentifier: String?

    public init(projectId: String? = nil, productId: String? = nil, planId: String? = nil, paymentId: String? = nil, blockchainIdentifier: String? = nil, blockchainPaymentDetails: CCPaymentBlockchainPaymentDetails? = nil, customerId: String? = nil, paymentValidationCode: String? = nil, periodEnd: Double? = nil, periodStart: Double? = nil, transactionBlockchainIdentifier: String? = nil) {
        self.projectId = projectId
        self.productId = productId
        self.planId = planId
        self.paymentId = paymentId
        self.blockchainIdentifier = blockchainIdentifier
        self.blockchainPaymentDetails = blockchainPaymentDetails
        self.customerId = customerId
        self.paymentValidationCode = paymentValidationCode
        self.periodEnd = periodEnd
        self.periodStart = periodStart
        self.transactionBlockchainIdentifier = transactionBlockchainIdentifier
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case projectId = "project_id"
        case productId = "product_id"
        case planId = "plan_id"
        case paymentId = "payment_id"
        case blockchainIdentifier = "blockchain_identifier"
        case blockchainPaymentDetails = "blockchain_payment_details"
        case customerId = "customer_id"
        case paymentValidationCode = "payment_validation_code"
        case periodEnd = "period_end"
        case periodStart = "period_start"
        case transactionBlockchainIdentifier = "transaction_blockchain_identifier"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(projectId, forKey: .projectId)
        try container.encodeIfPresent(productId, forKey: .productId)
        try container.encodeIfPresent(planId, forKey: .planId)
        try container.encodeIfPresent(paymentId, forKey: .paymentId)
        try container.encodeIfPresent(blockchainIdentifier, forKey: .blockchainIdentifier)
        try container.encodeIfPresent(blockchainPaymentDetails, forKey: .blockchainPaymentDetails)
        try container.encodeIfPresent(customerId, forKey: .customerId)
        try container.encodeIfPresent(paymentValidationCode, forKey: .paymentValidationCode)
        try container.encodeIfPresent(periodEnd, forKey: .periodEnd)
        try container.encodeIfPresent(periodStart, forKey: .periodStart)
        try container.encodeIfPresent(transactionBlockchainIdentifier, forKey: .transactionBlockchainIdentifier)
    }
}

