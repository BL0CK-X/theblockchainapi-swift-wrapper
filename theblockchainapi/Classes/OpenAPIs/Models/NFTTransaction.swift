//
// NFTTransaction.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct NFTTransaction: Codable, Hashable {

    public enum Exchange: String, Codable, CaseIterable {
        case solsea = "solsea"
        case magicEden = "magic-eden"
        case alphaArt = "alpha-art"
        case digitalEyes = "digital-eyes"
        case solanart = "solanart"
        case exchangeArt = "exchange-art"
    }
    public enum ExchangeReadable: String, Codable, CaseIterable {
        case solSea = "SolSea"
        case magicEden = "Magic Eden"
        case alphaArt = "Alpha Art"
        case digitalEyes = "Digital Eyes"
        case solanart = "Solanart"
        case exchangeArt = "Exchange.art"
    }
    public enum Operation: String, Codable, CaseIterable {
        case buy = "buy"
        case list = "list"
        case deList = "de_list"
        case updateListing = "update_listing"
    }
    /** An epoch time stamp in UTC time that represents the time of the block where the transaction was processed  */
    public var blockTime: Double?
    /** The NFT exchange on which the transaction occurred */
    public var exchange: Exchange?
    /** A readable version of the NFT exchange */
    public var exchangeReadable: ExchangeReadable?
    /** The mint address of the NFT  */
    public var mintAddress: String?
    /** The operation of the transaction */
    public var operation: Operation?
    /** The public key of the wallet that listed the NFT */
    public var seller: String?
    /** The public key of the buyer. This only exists in `buy` transactions.  */
    public var buyer: String?
    /** The signature of the transaction. You can look up each transaction on explorer.solana.com  */
    public var transactionSignature: String?

    public init(blockTime: Double? = nil, exchange: Exchange? = nil, exchangeReadable: ExchangeReadable? = nil, mintAddress: String? = nil, operation: Operation? = nil, seller: String? = nil, buyer: String? = nil, transactionSignature: String? = nil) {
        self.blockTime = blockTime
        self.exchange = exchange
        self.exchangeReadable = exchangeReadable
        self.mintAddress = mintAddress
        self.operation = operation
        self.seller = seller
        self.buyer = buyer
        self.transactionSignature = transactionSignature
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case blockTime = "block_time"
        case exchange
        case exchangeReadable = "exchange_readable"
        case mintAddress = "mint_address"
        case operation
        case seller
        case buyer
        case transactionSignature = "transaction_signature"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(blockTime, forKey: .blockTime)
        try container.encodeIfPresent(exchange, forKey: .exchange)
        try container.encodeIfPresent(exchangeReadable, forKey: .exchangeReadable)
        try container.encodeIfPresent(mintAddress, forKey: .mintAddress)
        try container.encodeIfPresent(operation, forKey: .operation)
        try container.encodeIfPresent(seller, forKey: .seller)
        try container.encodeIfPresent(buyer, forKey: .buyer)
        try container.encodeIfPresent(transactionSignature, forKey: .transactionSignature)
    }
}

