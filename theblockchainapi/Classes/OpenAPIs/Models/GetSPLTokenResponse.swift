//
// GetSPLTokenResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct GetSPLTokenResponse: Codable, JSONEncodable, Hashable {

    /** The number of decimals of the token. For example, if the USDC token has 6 decimals, then you need 1 * 10e6 = 1,000,000 tokens to have 1 USDC. The purpose of this is that everything must be stored as  an integer. Thus, if there are $100 USDC in total, there must be $100 * 10e6 tokens in order for the $100 to be divisible into lower denominations than $1.  */
    public var decimals: Double?
    /** Public key address */
    public var freezeAuthority: String?
    /** Public key address */
    public var mintAuthority: String?
    public var isInitialized: Bool?
    /** The supply of the token */
    public var supply: String?

    public init(decimals: Double? = nil, freezeAuthority: String? = nil, mintAuthority: String? = nil, isInitialized: Bool? = nil, supply: String? = nil) {
        self.decimals = decimals
        self.freezeAuthority = freezeAuthority
        self.mintAuthority = mintAuthority
        self.isInitialized = isInitialized
        self.supply = supply
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case decimals
        case freezeAuthority = "freeze_authority"
        case mintAuthority = "mint_authority"
        case isInitialized = "is_initialized"
        case supply
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(decimals, forKey: .decimals)
        try container.encodeIfPresent(freezeAuthority, forKey: .freezeAuthority)
        try container.encodeIfPresent(mintAuthority, forKey: .mintAuthority)
        try container.encodeIfPresent(isInitialized, forKey: .isInitialized)
        try container.encodeIfPresent(supply, forKey: .supply)
    }
}

